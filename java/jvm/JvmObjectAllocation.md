```
JVM对象分配过程
	据逃逸分析,判断是否能栈上分配
		如果可以,使用标量替换方式,把对象分配到VM Stack中.如果 线程销毁或方法调用结束后,自动销毁,不需要 GC 回收器 介入.
		否则,继续下一步
	判断是否大对象
		如果是,直接分配到堆上 Old Generation 老年代上.如果对象变为垃圾后,由老年代GC 收集器（比如 Parallel Old, CMS, G1）回收
		否则,继续下一步
	判断是否可以在 TLAB中分配	
		如果是,在 TLAB中分配堆上Eden区.
		否则,在 TLAB外堆上的Eden区分配
		
栈上分配:将线程私有的对象打散分配在栈 VM Stack上		
	可以在函数调用结束后自行销毁对象,不需要垃圾回收器的介入,有效避免垃圾回收带来的负面影响
	栈上分配速度快,提高系统性能
	栈空间小,对于大对象无法实现栈上分配
	基于逃逸分析、标量替换

逃逸分析
	Java Hotspot 虚拟机可以分析新创建对象的使用范围,并决定是否在 Java 堆上分配内存的一项技术
	逃逸分析的 JVM 参数如下
		开启逃逸分析：-XX:+DoEscapeAnalysis
		关闭逃逸分析：-XX:-DoEscapeAnalysis
		显示分析结果：-XX:+PrintEscapeAnalysis

逃逸分析优化,,当一个对象没有逃逸时,可以得到以下几个虚拟机的优化
	锁消除
		当编译器确定当前对象只有当前线程使用,那么就会移除该对象的同步锁
	标量替换
		首先要明白标量和聚合量,基础类型和对象的引用可以理解为标量,它们不能被进一步分解.而能被进一步分解的量就是聚合量,比如：对象
		对象是聚合量,它又可以被进一步分解成标量,将其成员变量分解为分散的变量,这就叫做标量替换
		如果一个对象没有发生逃逸,那压根就不用创建它,只会在栈或者寄存器上创建它用到的成员标量,节省了内存空间,也提升了应用程序性能.
	栈上分配	
		当对象没有发生逃逸时,该对象就可以通过标量替换分解成成员标量分配在栈内存中,和方法的生命周期一致,随着栈帧出栈时销毁,减少了 GC 压力,提高了应用程序性能.
		
TLAB 分配(Thread Local Allocation Buffer) 
	线程本地分配缓存.这是一块线程专用的内存分配区域
	TLAB占用的是eden区的空间,JVM会为每一个线程分配一块TLAB区域
为什么需要TLAB:这是为了加速对象的分配.
	由于对象一般分配在堆上,而堆是线程共用的,因此可能会有多个线程在堆上申请空间,而每一次的对象分配都必须线程同步,会使分配的效率下降.
	考虑到对象分配几乎是Java中最常用的操作,因此JVM使用了TLAB这样的线程专有区域来避免多线程冲突,提高对象分配的效率
	局限性： TLAB空间一般不会太大（占用eden区）,所以大对象无法进行TLAB分配,只能直接分配到堆 Heap上
```
		
		
		
		
		
		
		
		
		
		
		



















	
		
		
		
		
		
		
		
		
		
		
		
		
	
	
